import xml.etree.ElementTree as ET
import os
import csv
from fuzzywuzzy import fuzz
from fuzzywuzzy import process
from send2trash import send2trash


def parse_vrec_csv(csv_path='listTemp.csv'):
    """
    Reads a csv generated by a scraped v's page,
    parses it, then cleans it up for matching
    against a dat file.

    :param csv_path:
    :return:
    """

    # Read the csv file into a list.
    with open(csv_path, 'r', encoding='utf-8') as game_list:
        reader = csv.reader(game_list)
        results = list(filter(None, list(reader)))

    # Concatenate additional result sets into the first
    # set of results, if any.
    # Ex: Merge SuperCharger results into Atari 2600.
    names = []
    for page in results[1:]:
        names += page[0].split(',')

    # Remove a list of common accidental scrapes, then
    # return the final list for dat comparison.
    to_remove = [
        'Description',
        'Where To Buy',
        'Screenshot',
        'Genre',
        'Translation',
        'Title Screen',
        'Outbound Link',
        'Download'
    ]
    return sorted([x for x in names if x not in to_remove])


def parse_custom(file_path):
    """
    Parses an end-of-line delimited
    list from a text file.

    :param file_path:
    :return:
    """

    file = open(file_path, 'r', encoding='utf-8')
    return file.readlines()


def dat_clean(roms_to_keep, dat_file, dat_out=None, accuracy=90):
    """
    Checks each rom entry in a dat file against
    a list of roms to keep. If fuzzy matching fails,
    that rom entry is deleted from the final copy.

    It then writes a new dat file with only the entries
    that tested positive. This dat file can then be
    imported into the rom manager of your choice
    to delete all roms that were removed from said dat.

    :param roms_to_keep:
    :param dat_file:
    :param dat_out:
    :param accuracy:
    :return:
    """

    if dat_out is None:
        dat_out = os.path.splitext(dat_file)[0] + "clean.dat"

    # Read in dat file
    tree = ET.parse(dat_file)
    root = tree.getroot()

    # If game.get('name') does not fuzzy match source list, mark game for deletion.
    to_delete = []
    for game in root.iter('game'):
        result = process.extractOne(game.get('name'), roms_to_keep, score_cutoff=accuracy, scorer=fuzz.token_set_ratio)
        if not result:
            to_delete.append(game)

    # Delete all game xml blocks that were marked for deletion.
    for game in to_delete:
        root.remove(game)

    # Print the final xml to be used in a rom manager.
    tree.write(dat_out)


def dir_clean(rm_dir, clean_dat_file):
    """
    Checks a given directory against a cleaned dat file.
    If a filename doesn't match a dat entry's name exactly,
    it gets deleted.

    Reminds the user of what might be deleted and has an
    easy exit, due to its dangerous nature. It does however
    send files to trash as a safety net.

    This is really meant for odd use cases, such as when
    available romsets are older than available dats or
    a rom manager can't be used for any reason.

    :param rm_dir:
    :param clean_dat_file:
    :return:
    """

    reply = input("WARNING:This will trash all files not in "+clean_dat_file+' from '+rm_dir+' Proceed? (y/any): ')
    if reply != 'y':
        exit()

    if not rm_dir.endswith('/'):
        rm_dir = rm_dir+'/'

    # Read in dat file
    tree = ET.parse(clean_dat_file)
    root = tree.getroot()

    # Read in list of files
    files = os.listdir(rm_dir)

    # Extract all game names to a list
    files_to_keep = []
    for game in root.iter('game'):
            files_to_keep.append(game.get('name'))

    # If a file does not match any game names, delete it.
    for file in files:
        if os.path.splitext(file)[0] not in files_to_keep:
            send2trash(rm_dir+file)
